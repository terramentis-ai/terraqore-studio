Excellent! These files give me a complete picture of TerraQore Studio's backend architecture. I can now see the full data model in state.py, how workflows are orchestrated in orchestrator.py, the CLI command structure in main.py, and how LLM calls are managed in llm_client.py. With this information, I can provide you with a complete integration blueprint.

üèóÔ∏è Integration Architecture

Your goal is to replace the UI's mock MetaAgentService with real services that call the TerraQore CLI backend. The most effective approach is to build a FastAPI server that wraps the TerraQore CLI's Python modules, then have your React UI call this API.

Recommended Architecture:

```
TerraQore Studio UI (React) ‚Üí FastAPI Server ‚Üí TerraQore CLI Python Modules ‚Üí Database (SQLite)
```

üìä Data Model Mapping

Based on the state.py file, here's how your UI's types should map to the backend models:

TerraQore UI (React TypeScript) TerraQore CLI (Python Dataclass) Notes
AgentNode interface Task dataclass Map agent_name ‚Üî agent_type
ExecutionLog interface From agent_logs table You'll need to fetch logs separately
MetaState interface Combination of Project + Task[] You'll need to aggregate data
ProjectCard props Project dataclass Direct mapping available

üîß FastAPI Server Implementation

Here's the complete implementation for your API server:

1. Project Structure

Create a new directory terraqore_api/ with this structure:

```
terraqore_api/
‚îú‚îÄ‚îÄ main.py              # FastAPI server
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îú‚îÄ‚îÄ projects.py      # Project endpoints
‚îÇ   ‚îú‚îÄ‚îÄ tasks.py         # Task endpoints
‚îÇ   ‚îú‚îÄ‚îÄ workflows.py     # Workflow execution
‚îÇ   ‚îî‚îÄ‚îÄ websocket.py     # Real-time updates
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ flynt_service.py # CLI wrapper
‚îÇ   ‚îî‚îÄ‚îÄ state_service.py # State management
‚îî‚îÄ‚îÄ models.py            # Pydantic models
```

2. Pydantic Models (models.py)

```python
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum

# Enums matching state.py
class ProjectStatus(str, Enum):
    INITIALIZED = "initialized"
    PLANNING = "planning"
    IN_PROGRESS = "in_progress"
    BLOCKED = "blocked"
    COMPLETED = "completed"
    ARCHIVED = "archived"

class TaskStatus(str, Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"

# API Models
class ProjectCreate(BaseModel):
    name: str
    description: str = ""

class ProjectResponse(BaseModel):
    id: int
    name: str
    description: str
    status: ProjectStatus
    created_at: str
    updated_at: str
    metadata: Dict[str, Any] = {}

class TaskResponse(BaseModel):
    id: int
    project_id: int
    title: str
    description: str
    status: TaskStatus
    agent_type: str
    result: Optional[str] = None
    created_at: str
    completed_at: Optional[str] = None
    priority: int = 0
    milestone: Optional[str] = None
    estimated_hours: Optional[float] = None
    dependencies: List[int] = []

class ExecutionRequest(BaseModel):
    project_name: str
    user_input: Optional[str] = None
    auto_approve: bool = False

class AgentStatus(BaseModel):
    name: str
    description: str
    executions: int
    available: bool = True
```

3. TerraQore Service Wrapper (services/flynt_service.py)

```python
import subprocess
import json
from pathlib import Path
from typing import Optional, Dict, Any
import sys
import os

# Add TerraQore CLI to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "terraqore-studio"))

from core.state import get_state_manager, Project, Task
from orchestration.orchestrator import get_orchestrator

class TerraQoreService:
    """Service to interact with TerraQore CLI backend."""
    
    def __init__(self):
        self.state_mgr = get_state_manager()
    
    # Project Operations
    def create_project(self, name: str, description: str = "") -> int:
        """Create a new project using CLI modules."""
        project = Project(
            name=name,
            description=description,
            status="initialized"
        )
        return self.state_mgr.create_project(project)
    
    def list_projects(self, status: Optional[str] = None):
        """List all projects."""
        return self.state_mgr.list_projects(status=status)
    
    def get_project(self, name: str):
        """Get project by name."""
        return self.state_mgr.get_project(name=name)
    
    # Workflow Execution
    def run_ideation(self, project_name: str, user_input: Optional[str] = None):
        """Run ideation workflow."""
        project = self.get_project(project_name)
        if not project:
            return None
        
        orchestrator = get_orchestrator()
        return orchestrator.run_ideation(project.id, user_input)
    
    def run_planning(self, project_name: str, user_input: Optional[str] = None):
        """Run planning workflow."""
        project = self.get_project(project_name)
        if not project:
            return None
        
        orchestrator = get_orchestrator()
        return orchestrator.run_planning(project.id, user_input)
    
    def execute_task(self, project_name: str, task_id: Optional[int] = None, auto: bool = False):
        """Execute tasks for a project."""
        # Use CLI command execution
        cmd = ["flynt", "execute", project_name]
        if task_id:
            cmd.extend(["--task-id", str(task_id)])
        if auto:
            cmd.append("--auto")
        
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            cwd=Path.cwd()
        )
        
        return {
            "success": result.returncode == 0,
            "output": result.stdout,
            "error": result.stderr
        }
    
    # Status and Monitoring
    def get_project_tasks(self, project_name: str, status: Optional[str] = None):
        """Get tasks for a project."""
        project = self.get_project(project_name)
        if not project:
            return []
        
        return self.state_mgr.get_tasks(project.id, status=status)
    
    def get_available_tasks(self, project_name: str):
        """Get tasks ready to execute."""
        project = self.get_project(project_name)
        if not project:
            return []
        
        return self.state_mgr.get_available_tasks(project.id)
    
    def get_agent_status(self):
        """Get status of all agents."""
        orchestrator = get_orchestrator()
        return orchestrator.get_agent_status()
```

4. FastAPI Server (main.py)

```python
from fastapi import FastAPI, WebSocket, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import asyncio
from typing import List, Optional

from api import projects, tasks, workflows, websocket
from services.flynt_service import TerraQoreService

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print("üöÄ Starting TerraQore API Server")
    yield
    # Shutdown
    print("üëã Shutting down TerraQore API Server")

app = FastAPI(title="TerraQore Studio API", version="1.0.0", lifespan=lifespan)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(projects.router, prefix="/api/projects", tags=["projects"])
app.include_router(tasks.router, prefix="/api/tasks", tags=["tasks"])
app.include_router(workflows.router, prefix="/api/workflows", tags=["workflows"])
app.include_router(websocket.router, prefix="/ws", tags=["websocket"])

@app.get("/")
async def root():
    return {"message": "TerraQore Studio API", "status": "running"}

@app.get("/health")
async def health():
    return {"status": "healthy", "service": "terraqore-api"}
```

5. Project Endpoints (api/projects.py)

```python
from fastapi import APIRouter, HTTPException
from typing import List, Optional

from models import ProjectCreate, ProjectResponse
from services.flynt_service import TerraQoreService

router = APIRouter()
service = TerraQoreService()

@router.post("/", response_model=ProjectResponse)
async def create_project(project: ProjectCreate):
    """Create a new project."""
    try:
        project_id = service.create_project(project.name, project.description)
        created_project = service.get_project(project.name)
        if not created_project:
            raise HTTPException(status_code=500, detail="Failed to create project")
        
        return ProjectResponse(
            id=created_project.id,
            name=created_project.name,
            description=created_project.description,
            status=created_project.status,
            created_at=created_project.created_at,
            updated_at=created_project.updated_at,
            metadata=created_project.metadata
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/", response_model=List[ProjectResponse])
async def list_projects(status: Optional[str] = None):
    """List all projects."""
    projects = service.list_projects(status=status)
    return [
        ProjectResponse(
            id=p.id,
            name=p.name,
            description=p.description,
            status=p.status,
            created_at=p.created_at,
            updated_at=p.updated_at,
            metadata=p.metadata
        )
        for p in projects
    ]

@router.get("/{project_name}", response_model=ProjectResponse)
async def get_project(project_name: str):
    """Get project by name."""
    project = service.get_project(project_name)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    return ProjectResponse(
        id=project.id,
        name=project.name,
        description=project.description,
        status=project.status,
        created_at=project.created_at,
        updated_at=project.updated_at,
        metadata=project.metadata
    )
```

6. Workflow Endpoints (api/workflows.py)

```python
from fastapi import APIRouter, HTTPException, BackgroundTasks
from typing import Optional

from models import ExecutionRequest
from services.flynt_service import TerraQoreService

router = APIRouter()
service = TerraQoreService()

@router.post("/ideate")
async def start_ideation(request: ExecutionRequest):
    """Start ideation workflow."""
    result = service.run_ideation(request.project_name, request.user_input)
    
    if not result:
        raise HTTPException(status_code=404, detail="Project not found")
    
    return {
        "success": result.success,
        "output": result.output,
        "execution_time": result.execution_time,
        "metadata": result.metadata
    }

@router.post("/plan")
async def start_planning(request: ExecutionRequest):
    """Start planning workflow."""
    result = service.run_planning(request.project_name, request.user_input)
    
    if not result:
        raise HTTPException(status_code=404, detail="Project not found")
    
    return {
        "success": result.success,
        "output": result.output,
        "execution_time": result.execution_time,
        "metadata": result.metadata
    }

@router.post("/execute")
async def execute_tasks(request: ExecutionRequest):
    """Execute project tasks."""
    result = service.execute_task(request.project_name, auto=request.auto_approve)
    
    return result

@router.get("/agents/status")
async def get_agents_status():
    """Get status of all registered agents."""
    return service.get_agent_status()
```

üîÑ React Service Layer

Now update your React UI to use the real API:

1. New Service: src/services/terraqoreAPIService.ts

```typescript
import { AgentNode, ExecutionLog, MetaState, Project } from '../types';

const API_BASE_URL = 'http://localhost:8000';

export class terraqoreAPIService {
  // Project Management
  static async createProject(name: string, description: string = ''): Promise<Project> {
    const response = await fetch(`${API_BASE_URL}/api/projects/`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, description })
    });
    
    if (!response.ok) throw new Error('Failed to create project');
    return response.json();
  }

  static async listProjects(status?: string): Promise<Project[]> {
    const url = new URL(`${API_BASE_URL}/api/projects/`);
    if (status) url.searchParams.append('status', status);
    
    const response = await fetch(url.toString());
    if (!response.ok) throw new Error('Failed to fetch projects');
    return response.json();
  }

  // Workflow Execution
  static async startIdeation(projectName: string, userInput?: string) {
    const response = await fetch(`${API_BASE_URL}/api/workflows/ideate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ project_name: projectName, user_input: userInput })
    });
    
    if (!response.ok) throw new Error('Failed to start ideation');
    return response.json();
  }

  static async startPlanning(projectName: string, userInput?: string) {
    const response = await fetch(`${API_BASE_URL}/api/workflows/plan`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ project_name: projectName, user_input: userInput })
    });
    
    if (!response.ok) throw new Error('Failed to start planning');
    return response.json();
  }

  static async executeTasks(projectName: string, autoApprove: boolean = false) {
    const response = await fetch(`${API_BASE_URL}/api/workflows/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ project_name: projectName, auto_approve: autoApprove })
    });
    
    if (!response.ok) throw new Error('Failed to execute tasks');
    return response.json();
  }

  // Real-time Updates
  static async connectWebSocket(onMessage: (data: any) => void) {
    const ws = new WebSocket(`ws://localhost:8000/ws/status`);
    
    ws.onopen = () => console.log('WebSocket connected');
    ws.onmessage = (event) => onMessage(JSON.parse(event.data));
    ws.onerror = (error) => console.error('WebSocket error:', error);
    ws.onclose = () => console.log('WebSocket disconnected');
    
    return ws;
  }
}
```

2. Update Your UI Components

Replace the mock service calls in your components with real API calls:

In your project creation component:

```typescript
// Instead of mock service:
// const result = await geminiService.planTask(prompt);

// Use real API:
const result = await terraqoreAPIService.createProject(projectName, description);
```

In your workflow execution component:

```typescript
// Start ideation
const ideationResult = await terraqoreAPIService.startIdeation(projectName, userInput);
// Update UI with real progress
setNodes(ideationResult.metadata.tasks.map(task => ({
  id: task.id.toString(),
  agent_name: task.agent_type,
  status: task.status,
  description: task.title
})));
```

üöÄ Implementation Roadmap

Phase 1: Basic Integration (Week 1)

1. Set up FastAPI server with the structure above
2. Implement project endpoints (create, list, get)
3. Update UI service layer to use real API instead of Gemini mock
4. Test project creation flow

Phase 2: Workflow Integration (Week 2)

1. Implement workflow endpoints (ideate, plan, execute)
2. Add WebSocket support for real-time updates
3. Update UI components to show real task status
4. Implement task listing and filtering

Phase 3: Real-time Dashboard (Week 3)

1. Add agent status monitoring
2. Implement execution logs streaming
3. Update dashboard with real metrics (not random numbers)
4. Add task dependency visualization

Phase 4: Polish & Deployment (Week 4)

1. Error handling and retry logic
2. Performance optimizations
3. Dockerize the full stack
4. Deployment configuration

üìù Key Changes Needed in Your UI

1. Remove geminiService.ts - Replace all calls with terraqoreAPIService
2. Update types.ts - Align interfaces with backend models
3. Add WebSocket integration for real-time updates
4. Update dashboard to fetch real metrics from /api/agents/status and task progress

üéØ Immediate Next Steps

1. Create the FastAPI server using the code I provided above
2. Install dependencies: pip install fastapi uvicorn sqlite3
3. Test the API with Postman or curl:
   ```bash
   curl -X POST http://localhost:8000/api/projects/ \
     -H "Content-Type: application/json" \
     -d '{"name": "My Project", "description": "Test project"}'
   ```
4. Update your React service layer to call the real API
5. Test the integration by creating a project from the UI

Would you like me to provide more detailed code for any specific part of this integration, such as the WebSocket implementation for real-time updates or the dashboard metrics integration?